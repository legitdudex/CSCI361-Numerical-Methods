/*
 * Kang-hee Cho
 * Sateesh Mane
 * CS361 HW1: Convex Hull Part1
*/
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <math.h>
#include <vector>
#include <iterator>
#include <algorithm>


using namespace std;


class Point {
public:
	Point(double x1, double y1) : x(x1), y(y1) {
		y = sqrt(x*x + y*y);
		if(r > 0.0){
			theta = atan2(y, x);
		}
		else{
			theta = 0;
		}
	}
	
	double x;
	double y;
	double r;
	double theta;
}; 

bool vcomp(const Point &a, const Point &b){
        if(a.theta < b.theta){
                return true;
        }
        else if(a.theta > b.theta){
                return false;
        }
        return (a.r < b.r);
}
/*
 * Params{
 * 	n: number of points in the convex hull
 * 	arrays of x and y which of each make up the points themselves
 * 	}
 *
 * Outputs: An array of Point objects that represents our convex hull
 */
void convex_hull_func(int n, const std::vector<double> &x, const std::vector<double> &y, std::vector<Point> &convex_hull){
	const double tol = 1.0e-14;
	convex_hull.clear();
	if(n <= 0){ return; }
	else if(n <= 3){
		for(int i = 0; i < n; i++){
			convex_hull.push_back( Point(x[i], y[i]) );
		}
		convex_hull.push_back( Point(x[0], y[0]) );
		return;
	}
	int imin = 0;
	double y_min = y[0];
	double x_min = x[0];
	for(int i = 1; i < n; i++){
		if(y[i] < y_min){
			y_min = y[i];
			x_min = x[i];
			imin = i;
		}
		else if(y_min == y[i]){
			if(x[i] < x_min){
				x_min = x[i];
				y_min = y[i];
				imin = i;
			}
		}
	}

	vector<Point> v;
	for(int iv = 0; iv < n; iv++){
		double vx = x[iv] - x_min;
		double vy = y[iv] - y_min;
		if(iv == imin){
			vx = 0;
			vy = 0;
		}
		v.push_back( Point(vx, vy) );
	}	
	std::sort(v.begin(), v.end(), vcomp);

	for(int ip = 0; ip < n; ip++){
		v[ip].x += x_min;
		v[ip].y += y_min;
	}

	vector<Point> &p = v;
	convex_hull.push_back(p[0]);
	convex_hull.push_back(p[1]);

	int i = convex_hull.size();
	while(i < n){
		int last = convex_hull.size() - 1;
		int second_last = last - 1;
		double ux = convex_hull[last].x - convex_hull[second_last].x;
		double uy = convex_hull[last].y - convex_hull[second_last].y;
		double wx = p[i].x - convex_hull[last].x;
		double wy = p[i].y - convex_hull[last].y;
		
		double cross_product = ux*wy - uy*wx;
		if(cross_product > tol){
			convex_hull.push_back(p[i]);
			i++;
		}
		else if(fabs(cross_product) <= tol){
			convex_hull.pop_back();
			convex_hull.push_back(p[i]);
			i++;
		}
		else{
			convex_hull.pop_back();
		}
	}

	convex_hull.push_back(p[0]);	
}


int main(){
	//Testing with the test of points given in page 11 of the homework documentation
	int n = 10000;
	vector<double> x_vec;
	vector<double> y_vec;
	for(int i = 0; i < 100*n; i++){
		double x = cos(i%n);
		double y = sin(3 * (i%n)) * (1.0 - 0.5*x*x);
		x_vec.push_back(x);
		y_vec.push_back(y);

	}
	vector<Point> convex_hull;
	convex_hull_func(n, x_vec, y_vec, convex_hull);
	cout << "Testing Convex Hull: " << endl;
	cout << "The points in the convex hull given the plot of points generated by testing the test given in page 11 of the homework documentation is: " << endl << endl;
	for(int i = 0; i < convex_hull.size(); i++){
		cout << "x" << i << ": " << convex_hull[i].x << "          y" << i << ": " << convex_hull[i].y << endl;
	}
}











